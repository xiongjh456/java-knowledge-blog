---
id: redis
title: redis知识点
sidebar_position: 3
---

## 缓存穿透

概念：请求系统时，缓存中没有数据，数据库中也没有数据。

解决方法：
1. 接口增加业务层级的Filter，进行合法校验，这可以有效拦截大部分不合法的请求。
2. 作为第一点的补充，最常见的是使用布隆过滤器，针对一个或者多个维度，把可能存在的数据值hash到bitmap中，bitmap证明该数据不存在则该数据一定不存在，但是bitmap证明该数据存在也只能是可能存在，因为不同的数值hash到的bit位很有可能是一样的，hash冲突会导致误判，多个hash方法也只能是降低冲突的概率，无法做到避免。
3. 另外一个常见的方法，则是针对数据库与缓存都没有的数据，对空的结果进行缓存，但是过期时间设置得较短，一般五分钟内。而这种数据，如果数据库有写入，或者更新，必须同时刷新缓存，否则会导致不一致的问题存在。

## 缓存击穿

概念：请求系统时，缓存中没有数据，数据库中有数据。

解决方法：
1. 如果是热点数据，那么可以考虑设置永远不过期。
2. 如果数据一定会过期，那么就需要在数据为空的时候，设置一个互斥的锁，只让一个请求通过，只有一个请求去数据库拉取数据，取完数据，不管如何都需要释放锁，异常的时候也需要释放锁，要不其他线程会一直拿不到锁。

## 缓存雪崩

概念：大量请求访问系统时，缓存中的数据同一时刻大量失效，导致大量的请求落在数据库上。

解决方法：
1. 如果是热点数据，那么可以考虑设置永远不过期。
2. 缓存的过期时间如果不是比较严格，可以考虑设置一个波动随机值，比如理论十分钟，那这类key的缓存时间都加上一个1~3分钟，过期时间在7~13分钟内波动，有效防止都在同一个时间点上大量过期。
3. 方法1避免了有效过期的情况，但是要是所有的热点数据在一台redis服务器上，也是极其危险的，如果网络有问题，或者redis服务器挂了，那么所有的热点数据也会雪崩（查询不到），因此将热点数据打散分布到不同的机房中，也可以有效减少这种情况。
4. 也可以考虑双缓存的方式，数据库数据同步到缓存A和B，A设置过期时间，B不设置过期时间，如果A为空的时候去读B，同时异步去更新缓存，但是更新的时候需要同时更新两个缓存。
